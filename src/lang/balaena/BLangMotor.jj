options{  STATIC = false;  DEBUG_LOOKAHEAD = true;}PARSER_BEGIN(BLangMotor)package lang.balaena;import java.io.*;import java.util.*;import lang.balaena.recuperacao.*;import lang.balaena.arvore.*;import lang.balaena.semantico.*;import lang.balaena.codigo.*;/** * Classe do compilador Balaena */public class BLangMotor{  // Erros sintáticos  private static int qtdErroSintatico = 0;  // Controle de depuração da recuperação de erros  private static boolean debug_recuperacao = false;  // Controle da depuração da árvore sintática  private static boolean debug_arvore = false;  // Controle da depuração do código intermediário  private static boolean debug_intermediario = false;  // Controle para executar automaticamente o códgo objeto  private static boolean auto_executar = false;  // Arquivo do código fonte  private static String arquivo = "";  /**   * Obtém uma nova instância do compilador   * @param arquivo Caminho do arquivo do código fonte   * @return BLangMotor   */  public static BLangMotor getInstance(String arquivo)  {    BLangMotor motor;    try    {      motor = new BLangMotor(new FileInputStream(arquivo));    }    catch (FileNotFoundException e)    {      System.out.println("Arquivo \"" + arquivo + "\" não encontrado");      return null;    }    return motor;  }  /**   * Define se será exibido a depuração da recuperação de erros   */  public void setDebugRecuperacao(boolean debug)  {    this.debug_recuperacao = debug;  }  /**   * Define se será exibido a depuração da árvore sintática   */  public void setDebugArvore(boolean debug)  {    this.debug_arvore = debug;  }  /**   * Define o arquivo do código fonte   * @param arquivo Caminho do código fonte   */  public void setArquivo(String arquivo)  {    this.arquivo = arquivo;  }  /**   * Define se irá exibir o código intermediário no console   */  public void setIntermediario(boolean intermediario)  {    this.debug_intermediario = intermediario;  }  /**   * Define se irá executar automaticamente o código objeto   */  public void setAutoExecutar(boolean executar)  {    this.auto_executar = executar;  }  /**   * Inicia a execução do compilador   */  public void executar() throws ParseException  {    // Obtém o horário do início da compilação    Calendar inicio = Calendar.getInstance();    int erroSemantico = 0;    try    {      AnalisadorSemantico semantico = null;      GeradorCodigo gerador = null;      // Inicia a análise léxica e sintática      NoLista programa = this.programa();      // Enumera a árvore sintática      programa.setNumero(1);      // Verifica se irá executar a análise semântica      // Pra isto, não deve ter nenhum erro léxico e/ou sintático      if (this.token_source.errosLexicos() + this.qtdErroSintatico == 0)      {        if (debug_arvore)        {          System.out.println(programa);        }        // Cria uma instância do analisador semântico        semantico = new AnalisadorSemantico(programa);        try        {          // Inicia a análise semântica          semantico.analisa();          // Instancia o gerador de código          gerador = new GeradorCodigo(semantico, programa, arquivo, debug_intermediario);          // Inicia a geração de código intermediário e objeto          gerador.gerar();        }        catch (ErroSemanticoException e)        {          System.out.println(e.getMessage());        }        finally        {          if (semantico != null)          {            erroSemantico = semantico.getErros();          }        }      }    }    catch (ParseEOFException e)    {      System.out.println(e.getMessage());      qtdErroSintatico++;    }    finally    {      // Obtém o horário do final da compilação      Calendar fim = Calendar.getInstance();      // Calcula o tempo total      Calendar total = Calendar.getInstance();      total.setTimeInMillis(fim.getTimeInMillis() - inicio.getTimeInMillis());      // Calcula os segundos e milissegundos      int seg = total.get(Calendar.SECOND);      int mili = total.get(Calendar.MILLISECOND);      // Exibe o resultado da compilação      if (seg > 0)      {        System.out.println("Duração: " + seg + " segundos.");      }      else      {        System.out.println("Duração: " + mili + " milissegundos.");      }      System.out.println(this.token_source.errosLexicos() + " erros léxicos");      System.out.println(this.qtdErroSintatico + " erros sintáticos");      System.out.println(String.valueOf(erroSemantico) + " erros semânticos");      System.out.println((this.token_source.errosLexicos() + this.qtdErroSintatico + erroSemantico) + " erros totais");      // Executa o código objeto      if (auto_executar)      {        executaCodigo();      }    }  }  /**   * Método que executa automaticamente o código objeto   */  private void executaCodigo()  {    System.out.println("Ae");    Runtime console = Runtime.getRuntime();    try    {      File prog = GeradorCodigo.getPath();      console.exec("java -cp " + prog.getPath() + " " + GeradorCodigo.CLASSE).waitFor();    }    catch (IOException e)    {      System.out.println(e.getMessage());    }    catch (InterruptedException e1)    {      System.out.println(e1.getMessage());    }  }  /**   * Função para remoção das aspas duplas de um texto   * @param x Texto com aspas   * @return Texto sem aspas   */  public static String im(int x)  {    int k;    String s;    s = tokenImage [x];    k = s.lastIndexOf("\"");    try    {      s = s.substring(1, k);    }    catch (StringIndexOutOfBoundsException e)    {}    return s;  }  /**   * Executa a recuperação de erro   * @param recuperacao Lista de tokens de sincronização   * @param e Exceção que será lançada caso não encontre o token de sincronização   * @param terminal Não terminal que iniciou a recuperação de erro   * @throws ParseException Lançada quando não é encontrado o token de sincronização   * @throws ParseEOFException Lançada quando é encontrado o final do arquivo prematuramente   */  public void consumirAte(Recuperacao recuperacao, ParseException e, String terminal) throws ParseEOFException, ParseException  {    if (debug_recuperacao)    {      System.out.println("\n# TERMINAL: " + terminal + " #");      System.out.println("Cadeia de sincronização: " + recuperacao);    }    // Propaga a exceção caso não exista o conjunto de sincronização    if (recuperacao == null)    {      throw e;    }    boolean eof = false;    // Consome um token    Token token = getToken(1);    while (!eof)    {      // Verifica se está no conjunto de sincronização      if (recuperacao.contains(token.kind))      {        if (debug_recuperacao)        {          System.out.println("Token de sincronização encontrado: " + im(token.kind));        }        break;      }      if (debug_recuperacao)      {        System.out.println("Token ignorado: " + im(token.kind));      }      // Consome outro token      getNextToken();      token = getToken(1);      // Verifica se é o final do arquivo      if (token.kind == EOF && !recuperacao.contains(token.kind))      {        eof = true;      }    }    // Exibe a mensagem do erro, porém houve a recuperação    System.out.println(e.getMessage());    // Incrementa o contador de erros    qtdErroSintatico++;    if (eof) throw new ParseEOFException("Fim do arquivo encontrado");  }}PARSER_END(BLangMotor)TOKEN_MGR_DECLS :{  private int qtdErrosLexicos = 0;  public int errosLexicos()  {    return qtdErrosLexicos;  }}/* Caracteres a serem ignorados */SKIP :{  " "| "\r"| "\t"| "\n"| "\f"}/* Palavras reservadas */TOKEN :{  < SENAO : "senao" >| < SE : "se" >| < INTEIRO : "inteiro" >| < DECIMAL : "decimal" >| < TEXTO : "texto" >| < VAZIO : "vazio" >| < NOVO : "novo" >| < ESCREVER : "escrever" >| < LER : "ler" >| < RETORNA : "retorna" >| < METODO : "metodo" >| < PRINCIPAL : "principal" >| < ENQUANTO : "enquanto" >| < VARIAVEL : "variavel" >}/* Operadores */TOKEN :{  < ATRIBUICAO : "=" >| < MAIOR : ">" >| < MENOR : "<" >| < IGUAL : "==" >| < MAIORIGUAL : ">=" >| < MENORIGUAL : "<=" >| < DIFERENTE : "!=" >| < MAIS : "+" >| < MENOS : "-" >| < MULTIPLICACAO : "*" >| < DIVISAO : "/" >| < RESTO : "%" >}/* Símbolos especiais */TOKEN :{  < PARENESQ : "(" >| < PARENDIR : ")" >| < CHAVEESQ : "{" >| < CHAVEDIR : "}" >| < COLCHESQ : "[" >| < COLCHDIR : "]" >| < VIRGULA : "," >| < PONTO : "." >}/* Tokens auxiliares */TOKEN :{  < #DIGITO : [ "0"-"9" ] >| < #LETRA : [ "a"-"z", "A"-"Z" ] >}/* Constantes */TOKEN :{  < CONST_INTEIRO :    (      < DIGITO > (< DIGITO >)*    ) >| < CONST_DECIMAL : < CONST_INTEIRO > < PONTO > < CONST_INTEIRO >>| < CONST_TEXTO : "\"" (~[ "\"", "\n", "\r" ])* "\"" >| < CONST_NULO : "nulo" >}/* Identificadores */TOKEN :{  < IDENT :    < LETRA >    (      < LETRA >    | < DIGITO >    )* >}NoLista programa() throws ParseEOFException :{  Recuperacao r = new Recuperacao(EOF);  NoLista metodos = null;}{  try  {    [ metodos = lista_metodo(r) ] < EOF >    {      return metodos;    }  }  catch (ParseException e)  {    consumirAte(r, e, "programa");    return metodos;  }}NoLista lista_metodo(Recuperacao rec) throws ParseEOFException :{  NoLista metodos = null;  NoMetodoDecl metodo = null;}{  try  {    (LOOKAHEAD(5)    metodo = decl_metodo(rec)    {      if (metodos == null)      {        metodos = new NoLista(metodo);      }      else      {        metodos.adiciona(metodo);      }    }    ) * metodo = metodo_principal(rec)    {      if (metodos == null)      {        metodos = new NoLista(metodo);      }      else      {        metodos.adiciona(metodo);      }    }    (LOOKAHEAD(5)    metodo = decl_metodo(rec)    {      if (metodos == null)      {        metodos = new NoLista(metodo);      }      else      {        metodos.adiciona(metodo);      }    }    ) *    {      return metodos;    }  }  catch (ParseException e)  {    consumirAte(rec, e, "lista_metodo");    return metodos;  }}NoMetodoDecl decl_metodo(Recuperacao rec) throws ParseEOFException :{  Token tipo = null;  Token nome = null;  int tamanho = 0;  NoCorpoMetodo corpo = null;}{  try  {    < METODO > (tipo = tipo_primitivo(rec) [ tamanho = decl_array() ]  | tipo = < VAZIO >) nome = < IDENT > corpo = corpo_metodo(rec)    {      return new NoMetodoDecl(tipo, tamanho, nome, corpo);    }  }  catch (ParseException e)  {    consumirAte(rec, e, "decl_metodo");    return new NoMetodoDecl(tipo, tamanho, nome, corpo);  }}int decl_array() :{  int tamanho = 0;}{  (< COLCHESQ > < COLCHDIR >  {    tamanho++;  }  )+  {    return tamanho;  }}Token tipo_primitivo(Recuperacao rec) throws ParseEOFException :{  Token resultado = null;}{  try  {    (resultado = < INTEIRO >  | resultado = < DECIMAL >  | resultado = < TEXTO >)    {      return resultado;    }  }  catch (ParseException e)  {    consumirAte(rec, e, "tipo_primitivo");    return resultado;  }}NoMetodoDecl metodo_principal(Recuperacao rec) throws ParseEOFException :{  Token nome = null;  NoCorpoMetodo corpo = null;  NoBloco bloco = null;  Token ref = null;  Token tipo = null;}{  try  {    < METODO > tipo = < VAZIO > nome = < PRINCIPAL > ref = < PARENESQ > < PARENDIR > bloco = bloco(rec)    {      corpo = new NoCorpoMetodo(ref, null, bloco);      return new NoMetodoDecl(tipo, 0, nome, corpo);    }  }  catch (ParseException e)  {    consumirAte(rec, e, "metodo_principal");    return new NoMetodoDecl(null, 0, nome, null);  }}NoCorpoMetodo corpo_metodo(Recuperacao rec) throws ParseEOFException :{  Recuperacao r = new Recuperacao(PARENDIR);  Token ref = null;  NoLista parametros = null;  NoBloco bloco = null;}{  try  {    ref = < PARENESQ > [ parametros = parametros(r) ] < PARENDIR > bloco = bloco(rec)    {      return new NoCorpoMetodo(ref, parametros, bloco);    }  }  catch (ParseException e)  {    consumirAte(rec, e, "corpo_metodo");    return new NoCorpoMetodo(ref, parametros, bloco);  }}NoLista parametros(Recuperacao rec) throws ParseEOFException :{  NoLista resultado = null;  NoVariavelDecl variaveis = null;  NoVariavel variavel = null;  Token tipo = null;  Token nome = null;}{  try  {    tipo = tipo_primitivo(rec) nome = < IDENT >    {      variavel = new NoVariavel(nome);      variaveis = new NoVariavelDecl(tipo, variavel);      resultado = new NoLista(variaveis);    }    (< VIRGULA > tipo = tipo_primitivo(rec) nome = < IDENT >    {      variavel = new NoVariavel(nome);      variaveis = new NoVariavelDecl(tipo, variavel);      if (resultado == null)      {        resultado = new NoLista(variaveis);      }      else      {        resultado.adiciona(variaveis);      }    }    ) *    {      return resultado;    }  }  catch (ParseException e)  {    consumirAte(rec, e, "parametros");    return resultado;  }}NoBloco bloco(Recuperacao rec) throws ParseEOFException :{  Recuperacao r = new Recuperacao(CHAVEDIR);  NoDeclaracao declaracao = null;  NoLista declaracoes = null;  Token ref = null;}{  try  {    ref = < CHAVEESQ > (declaracao = declaracao(r)    {      if (declaracoes == null)      {        declaracoes = new NoLista(declaracao);      }      else      {        declaracoes.adiciona(declaracao);      }    }    ) * < CHAVEDIR >    {      return new NoBloco(ref, declaracoes);    }  }  catch (ParseException e)  {    consumirAte(rec, e, "bloco");    return new NoBloco(ref, declaracoes);  }}NoDeclaracao declaracao(Recuperacao rec) throws ParseEOFException :{  NoDeclaracao dec = null;}{  try  {    (dec = decl_variavel(rec)  | LOOKAHEAD(2)    dec = atribuicao(rec)  | dec = decl_chamada_metodo(rec)  | dec = comando_imprimir(rec)  | dec = comando_ler(rec)  | dec = comando_retornar(rec)  | dec = controle_se(rec)  | dec = controle_enquanto(rec))    {      return dec;    }  }  catch (ParseException e)  {    consumirAte(rec, e, "declaracao");    return dec;  }}NoVariavelDecl decl_variavel(Recuperacao rec) throws ParseEOFException :{  Recuperacao r = new Recuperacao(VIRGULA);  Token tipo = null;  NoVariavel variavel = null;  NoLista variaveis = null;  NoVariavelDecl resultado = null;}{  try  {    < VARIAVEL > tipo = tipo_primitivo(r) variavel = ident_variavel(r)    {      variaveis = new NoLista(variavel);    }    (< VIRGULA > variavel = ident_variavel(rec)    {      variaveis.adiciona(variavel);    }    ) *    {      return new NoVariavelDecl(tipo, variaveis);    }  }  catch (ParseException e)  {    consumirAte(rec, e, "decl_variavel");    return new NoVariavelDecl(tipo, variaveis);  }}NoVariavel ident_variavel(Recuperacao rec) throws ParseEOFException :{  Token nome = null;  int tamanho = 0;}{  try  {    nome = < IDENT > [ tamanho = decl_array() ]    {      return new NoVariavel(nome, tamanho);    }  }  catch (ParseException e)  {    consumirAte(rec, e, "ident_variavel");    return new NoVariavel(nome, tamanho);  }}NoAtribuicao atribuicao(Recuperacao rec) throws ParseEOFException :{  Recuperacao r = new Recuperacao(ATRIBUICAO);  NoExpressao esquerda = null;  NoExpressao direita = null;  Token igual = null;}{  try  {    esquerda = valor_esquerdo(r) igual = < ATRIBUICAO > (direita = expressao(rec)  | direita = alocacao(rec))    {      return new NoAtribuicao(igual, esquerda, direita);    }  }  catch (ParseException e)  {    consumirAte(rec, e, "atribuicao");    return new NoAtribuicao(igual, esquerda, direita);  }}NoExpressao valor_esquerdo(Recuperacao rec) throws ParseEOFException :{  Recuperacao r = new Recuperacao(COLCHDIR);  Token nome = null;  NoExpressao expr = null;  NoLista lista = null;  NoVariavel variavel = null;}{  try  {    nome = < IDENT > (< COLCHESQ > expr = expressao(r) < COLCHDIR >    {      if (lista == null)      {        lista = new NoLista(expr);      }      else      {        lista.adiciona(expr);      }    }    ) *    {      if (lista != null)      {        return new NoArray(nome, lista);      }      else      {        return new NoVariavel(nome);      }    }  }  catch (ParseException e)  {    consumirAte(rec, e, "valor_esquerdo");    return new NoVariavel(nome);  }}NoAlocacao alocacao(Recuperacao rec) throws ParseEOFException :{  Recuperacao recTipo = new Recuperacao(COLCHESQ);  Recuperacao recExpr = new Recuperacao(COLCHDIR);  Token novo = null;  Token tipo = null;  NoExpressao tamanho = null;  NoLista array = null;}{  try  {    novo = < NOVO > tipo = tipo_primitivo(recTipo) (< COLCHESQ > tamanho = expressao(recExpr) < COLCHDIR >    {      if (array == null)      {        array = new NoLista(tamanho);      }      else      {        array.adiciona(tamanho);      }    }    ) +    {      return new NoAlocacao(novo, tipo, array);    }  }  catch (ParseException e)  {    consumirAte(rec, e, "alocacao");    return new NoAlocacao(novo, tipo, array);  }}NoExpressao expressao(Recuperacao rec) throws ParseEOFException :{  NoExpressao resultado = null;  NoExpressao esquerda = null;  NoExpressao direita = null;  Token operador = null;}{  try  {    (LOOKAHEAD(2)    esquerda = expressao_numerica()  | LOOKAHEAD(2)    esquerda = chamada_metodo(rec))    {      resultado = esquerda;    }    [      operador = operador_binario() (LOOKAHEAD(2)      direita = expressao_numerica()    | LOOKAHEAD(2)      direita = chamada_metodo(rec))      {        resultado = new NoRelacional(operador, esquerda, direita);      }    ]    {      return resultado;    }  }  catch (ParseException e)  {    consumirAte(rec, e, "expressao");    return resultado;  }}Token operador_binario() :{  Token op = null;}{  (    op = < MAIOR >  | op = < MENOR >  | op = < IGUAL >  | op = < MAIORIGUAL >  | op = < MENORIGUAL >  | op = < DIFERENTE >  )  {    return op;  }}NoChamadaDecl decl_chamada_metodo(Recuperacao rec) throws ParseEOFException :{  NoChamada chamada = null;}{  chamada = chamada_metodo(rec)  {    return new NoChamadaDecl(chamada);  }}NoChamada chamada_metodo(Recuperacao rec) throws ParseEOFException :{  Recuperacao r = new Recuperacao(PARENDIR);  Token metodo = null;  NoLista argumentos = null;}{  try  {    metodo = < IDENT > < PARENESQ > [ argumentos = argumentos(r) ] < PARENDIR >    {      return new NoChamada(metodo, argumentos);    }  }  catch (ParseException e)  {    consumirAte(rec, e, "chamada_metodo");    return new NoChamada(metodo, argumentos);  }}NoLista argumentos(Recuperacao rec) throws ParseEOFException :{  NoLista resultado = null;  NoExpressao expr = null;}{  try  {    expr = expressao(rec)    {      resultado = new NoLista(expr);    }    (< VIRGULA > expr = expressao(rec)    {      resultado.adiciona(expr);    }    ) *    {      return resultado;    }  }  catch (ParseException e)  {    consumirAte(rec, e, "argumentos");    return resultado;  }}NoExpressao expressao_numerica() throws ParseEOFException :{  Token op = null;  NoExpressao esquerda = null;  NoExpressao direita = null;}{  esquerda = termo()  (    (      op = < MAIS >    | op = < MENOS >    )    direita = termo()    {      esquerda = new NoAdicao(op, esquerda, direita);    }  )*  {    return esquerda;  }}NoExpressao termo() throws ParseEOFException :{  NoExpressao esquerda = null;  NoExpressao direita = null;  Token op = null;}{  esquerda = expressao_unaria()  (    (      op = < MULTIPLICACAO >    | op = < DIVISAO >    | op = < RESTO >    )    direita = expressao_unaria()    {      esquerda = new NoMultiplicacao(op, esquerda, direita);    }  )*  {    return esquerda;  }}NoExpressao expressao_unaria() throws ParseEOFException :{  Token op = null;  NoExpressao fator = null;}{  [    op = < MAIS >  | op = < MENOS >  ]  fator = fator()  {    if (op == null)    {      return fator;    }    else    {      return new NoUnario(op, fator);    }  }}NoExpressao fator() throws ParseEOFException :{  Recuperacao r = new Recuperacao(PARENDIR);  NoExpressao fator = null;  Token constante = null;}{  (    constante = < CONST_INTEIRO >    {      fator = new NoInteiro(constante);    }  | constante = < CONST_DECIMAL >    {      fator = new NoDecimal(constante);    }  | constante = < CONST_TEXTO >    {      fator = new NoTexto(constante);    }  | constante = < CONST_NULO >    {      fator = new NoNulo(constante);    }  | fator = valor_esquerdo(null)  | < PARENESQ > fator = expressao(r) < PARENDIR >  )  {    return fator;  }}NoImprimir comando_imprimir(Recuperacao rec) throws ParseEOFException :{  Recuperacao r = new Recuperacao(PARENDIR);  Token escrever = null;  NoExpressao valor = null;}{  try  {    escrever = < ESCREVER > < PARENESQ > valor = expressao(r) < PARENDIR >    {      return new NoImprimir(escrever, valor);    }  }  catch (ParseException e)  {    consumirAte(rec, e, "comando_imprimir");    return new NoImprimir(escrever, valor);  }}NoLer comando_ler(Recuperacao rec) throws ParseEOFException :{  Recuperacao r = new Recuperacao(PARENDIR);  Token ler = null;  NoExpressao variavel = null;}{  try  {    ler = < LER > < PARENESQ > variavel = expressao(r) < PARENDIR >    {      return new NoLer(ler, variavel);    }  }  catch (ParseException e)  {    consumirAte(rec, e, "comando_ler");    return new NoLer(ler, variavel);  }}NoRetornar comando_retornar(Recuperacao rec) throws ParseEOFException :{  Token retorna = null;  NoExpressao valor = null;}{  try  {    retorna = < RETORNA >    [      LOOKAHEAD(2)      valor = expressao(rec)    ]    {      return new NoRetornar(retorna, valor);    }  }  catch (ParseException e)  {    consumirAte(rec, e, "comando_retornar");    return new NoRetornar(retorna, valor);  }}NoSe controle_se(Recuperacao rec) throws ParseEOFException :{  Recuperacao r = new Recuperacao(PARENDIR);  Token se = null;  NoExpressao condicao = null;  NoBloco verdadeiro = null;  NoBloco falso = null;}{  try  {    se = < SE > < PARENESQ > condicao = expressao(r) < PARENDIR > verdadeiro = bloco(rec)    [      LOOKAHEAD(2)      < SENAO > falso = bloco(rec)    ]    {      return new NoSe(se, condicao, verdadeiro, falso);    }  }  catch (ParseException e)  {    consumirAte(rec, e, "comando_se");    return new NoSe(se, condicao, verdadeiro, falso);  }}NoEnquanto controle_enquanto(Recuperacao rec) throws ParseEOFException :{  Recuperacao r = new Recuperacao(PARENDIR);  Token enquanto = null;  NoExpressao condicao = null;  NoBloco bloco = null;}{  try  {    enquanto = < ENQUANTO > < PARENESQ > condicao = expressao(r) < PARENDIR > bloco = bloco(rec)    {      return new NoEnquanto(enquanto, condicao, bloco);    }  }  catch (ParseException e)  {    consumirAte(rec, e, "controle_enquanto");    return new NoEnquanto(enquanto, condicao, bloco);  }}