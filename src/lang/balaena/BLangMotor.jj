options{  STATIC = false;  DEBUG_LOOKAHEAD = true;}PARSER_BEGIN(BLangMotor)package lang.balaena;import java.io.*;import lang.balaena.recuperacao.*;import lang.balaena.arvore.*;import lang.balaena.semantico.*;import lang.balaena.codigo.*;public class BLangMotor{  private static int qtdErroSintatico = 0;  private static boolean debug_recuperacao = false;  private static boolean debug_arvore = false;  private static String arquivo = "";  public static BLangMotor getInstance(String arquivo, boolean debug, boolean recuperacao, boolean arvore)  {    BLangMotor motor;    if (arquivo.isEmpty())    {      motor = new BLangMotor(System.in);    }    else    {      try      {        motor = new BLangMotor(new FileInputStream(arquivo));      }      catch (FileNotFoundException e)      {        System.out.println("Arquivo \"" + arquivo + "\" não encontrado");        return null;      }    }    if (!debug)    {      motor.disable_tracing();    }    motor.setDebugRecuperacao(recuperacao);    motor.setDebugArvore(arvore);    motor.setArquivo(arquivo);    return motor;  }  public void setDebugRecuperacao(boolean debug)  {    this.debug_recuperacao = debug;  }  public void setDebugArvore(boolean debug)  {    this.debug_arvore = debug;  }  public void setArquivo(String arquivo)  {    this.arquivo = arquivo;  }  public void executar() throws ParseException  {    int erroSemantico = 0;    try    {      AnalisadorSemantico semantico = null;      GeradorCodigo gerador = null;      NoLista programa = this.programa();      programa.setNumero(1);      if (this.token_source.errosLexicos() + this.qtdErroSintatico == 0)      {        if (debug_arvore)        {          System.out.println(programa);        }        semantico = new AnalisadorSemantico(programa);        try        {          semantico.analisa();          gerador = new GeradorCodigo(semantico, programa, arquivo);          gerador.gerar();        }        catch (ErroSemanticoException e)        {          System.out.println(e.getMessage());        }        finally        {          if (semantico != null)          {            erroSemantico = semantico.getErros();          }        }      }    }    catch (ParseEOFException e)    {      System.out.println(e.getMessage());      qtdErroSintatico++;    }    finally    {      System.out.println(this.token_source.errosLexicos() + " erros léxicos encontrados");      System.out.println(this.qtdErroSintatico + " erros sintáticos encontrados");      System.out.println(String.valueOf(erroSemantico) + " erros semânticos encontrados");      System.out.println((this.token_source.errosLexicos() + this.qtdErroSintatico + erroSemantico) + " erros totais");    }  }  public static String im(int x)  {    int k;    String s;    s = tokenImage [x];    k = s.lastIndexOf("\"");    try    {      s = s.substring(1, k);    }    catch (StringIndexOutOfBoundsException e)    {}    return s;  }  public void consumirAte(Recuperacao recuperacao, ParseException e, String terminal) throws ParseEOFException, ParseException  {    if (debug_recuperacao)    {      System.out.println("\n# TERMINAL: " + terminal + " #");      System.out.println("Cadeia de sincronização: " + recuperacao);    }    // Propaga a exceção    if (recuperacao == null)    {      throw e;    }    boolean eof = false;    Token token = getToken(1);    while (!eof)    {      if (recuperacao.contains(token.kind))      {        if (debug_recuperacao)        {          System.out.println("Token de sincronização encontrado: " + im(token.kind));        }        break;      }      if (debug_recuperacao)      {        System.out.println("Token ignorado: " + im(token.kind));      }      getNextToken();      token = getToken(1);      if (token.kind == EOF && !recuperacao.contains(token.kind))      {        eof = true;      }    }    System.out.println(e.getMessage());    qtdErroSintatico++;    if (eof) throw new ParseEOFException("Fim do arquivo encontrado");  }}PARSER_END(BLangMotor)TOKEN_MGR_DECLS :{  private int qtdErrosLexicos = 0;  public int errosLexicos()  {    return qtdErrosLexicos;  }}SKIP :{  " "| "\r"| "\t"| "\n"| "\f"}/* Palavras reservadas */TOKEN :{  < BREAK : "interrompe" >| < SENAO : "senao" >| < SE : "se" >| < PARA : "para" >| < INTEIRO : "inteiro" >| < DECIMAL : "decimal" >| < TEXTO : "texto" >| < VAZIO : "vazio" >| < NOVO : "novo" >| < ESCREVER : "escrever" >| < LER : "ler" >| < RETORNA : "retorna" >| < METODO : "metodo" >| < PRINCIPAL : "principal" >| < ENQUANTO : "enquanto" >| < VARIAVEL : "variavel" >}/* Operadores */TOKEN :{  < ATRIBUICAO : "=" >| < MAIOR : ">" >| < MENOR : "<" >| < IGUAL : "==" >| < MAIORIGUAL : ">=" >| < MENORIGUAL : "<=" >| < DIFERENTE : "!=" >| < MAIS : "+" >| < MENOS : "-" >| < MULTIPLICACAO : "*" >| < DIVISAO : "/" >| < RESTO : "%" >}/* Símbolos especiais */TOKEN :{  < PARENESQ : "(" >| < PARENDIR : ")" >| < CHAVEESQ : "{" >| < CHAVEDIR : "}" >| < COLCHESQ : "[" >| < COLCHDIR : "]" >| < PONTOVIRGULA : ";" >| < VIRGULA : "," >| < PONTO : "." >}/* Auxiliares */TOKEN :{  < #DIGITO : [ "0"-"9" ] >| < #LETRA : [ "a"-"z", "A"-"Z" ] >}/* Constantes */TOKEN :{  < CONST_INTEIRO :    (      < DIGITO > (< DIGITO >)*    ) >| < CONST_DECIMAL : < CONST_INTEIRO > < PONTO > < CONST_INTEIRO >>| < CONST_TEXTO : "\"" (~[ "\"", "\n", "\r" ])* "\"" >| < CONST_NULO : "nulo" >}/* Identificadores */TOKEN :{  < IDENT :    < LETRA >    (      < LETRA >    | < DIGITO >    )* >}NoLista programa() throws ParseEOFException :{  Recuperacao r = new Recuperacao(EOF);  NoLista metodos = null;}{  try  {    [ metodos = lista_metodo(r) ] < EOF >    {      return metodos;    }  }  catch (ParseException e)  {    consumirAte(r, e, "programa");    return metodos;  }}NoLista lista_metodo(Recuperacao rec) throws ParseEOFException :{  NoLista metodos = null;  NoMetodoDecl metodo = null;}{  try  {    (LOOKAHEAD(5)    metodo = decl_metodo(rec)    {      if (metodos == null)      {        metodos = new NoLista(metodo);      }      else      {        metodos.adiciona(metodo);      }    }    ) * metodo = metodo_principal(rec)    {      if (metodos == null)      {        metodos = new NoLista(metodo);      }      else      {        metodos.adiciona(metodo);      }    }    (LOOKAHEAD(5)    metodo = decl_metodo(rec)    {      if (metodos == null)      {        metodos = new NoLista(metodo);      }      else      {        metodos.adiciona(metodo);      }    }    ) *    {      return metodos;    }  }  catch (ParseException e)  {    consumirAte(rec, e, "lista_metodo");    return metodos;  }}int decl_array() :{  int tamanho = 0;}{  (< COLCHESQ > < COLCHDIR >  {    tamanho++;  }  )+  {    return tamanho;  }}Token tipo_primitivo(Recuperacao rec) throws ParseEOFException :{  Token resultado = null;}{  try  {    (resultado = < INTEIRO >  | resultado = < DECIMAL >  | resultado = < TEXTO >)    {      return resultado;    }  }  catch (ParseException e)  {    consumirAte(rec, e, "tipo_primitivo");    return resultado;  }}NoMetodoDecl decl_metodo(Recuperacao rec) throws ParseEOFException :{  Token tipo = null;  Token nome = null;  int tamanho = 0;  NoCorpoMetodo corpo = null;}{  try  {    < METODO > (tipo = tipo_primitivo(rec) [ tamanho = decl_array() ]  | tipo = < VAZIO >) nome = < IDENT > corpo = corpo_metodo(rec)    {      return new NoMetodoDecl(tipo, tamanho, nome, corpo);    }  }  catch (ParseException e)  {    consumirAte(rec, e, "decl_metodo");    return new NoMetodoDecl(tipo, tamanho, nome, corpo);  }}NoMetodoDecl metodo_principal(Recuperacao rec) throws ParseEOFException :{  Token nome = null;  NoCorpoMetodo corpo = null;  NoBloco bloco = null;  Token ref = null;  Token tipo = null;}{  try  {    < METODO > tipo = < VAZIO > nome = < PRINCIPAL > ref = < PARENESQ > < PARENDIR > bloco = bloco(rec)    {      corpo = new NoCorpoMetodo(ref, null, bloco);      return new NoMetodoDecl(tipo, 0, nome, corpo);    }  }  catch (ParseException e)  {    consumirAte(rec, e, "metodo_principal");    return new NoMetodoDecl(null, 0, nome, null);  }}NoCorpoMetodo corpo_metodo(Recuperacao rec) throws ParseEOFException :{  Recuperacao r = new Recuperacao(PARENDIR);  Token ref = null;  NoLista parametros = null;  NoBloco bloco = null;}{  try  {    ref = < PARENESQ > [ parametros = parametros(r) ] < PARENDIR > bloco = bloco(rec)    {      return new NoCorpoMetodo(ref, parametros, bloco);    }  }  catch (ParseException e)  {    consumirAte(rec, e, "corpo_metodo");    return new NoCorpoMetodo(ref, parametros, bloco);  }}NoLista parametros(Recuperacao rec) throws ParseEOFException :{  NoLista resultado = null;  NoVariavelDecl variaveis = null;  NoVariavel variavel = null;  Token tipo = null;  Token nome = null;}{  try  {    tipo = tipo_primitivo(rec) nome = < IDENT >    {      variavel = new NoVariavel(nome);      variaveis = new NoVariavelDecl(tipo, variavel);      resultado = new NoLista(variaveis);    }    (< VIRGULA > tipo = tipo_primitivo(rec) nome = < IDENT >    {      variavel = new NoVariavel(nome);      variaveis = new NoVariavelDecl(tipo, variavel);      if (resultado == null)      {        resultado = new NoLista(variaveis);      }      else      {        resultado.adiciona(variaveis);      }    }    ) *    {      return resultado;    }  }  catch (ParseException e)  {    consumirAte(rec, e, "parametros");    return resultado;  }}NoBloco bloco(Recuperacao rec) throws ParseEOFException :{  Recuperacao r = new Recuperacao(CHAVEDIR);  NoDeclaracao declaracao = null;  NoLista declaracoes = null;  Token ref = null;}{  try  {    ref = < CHAVEESQ > (declaracao = declaracao(r)    {      if (declaracoes == null)      {        declaracoes = new NoLista(declaracao);      }      else      {        declaracoes.adiciona(declaracao);      }    }    ) * < CHAVEDIR >    {      return new NoBloco(ref, declaracoes);    }  }  catch (ParseException e)  {    consumirAte(rec, e, "bloco");    return new NoBloco(ref, declaracoes);  }}NoDeclaracao declaracao(Recuperacao rec) throws ParseEOFException :{  NoDeclaracao dec = null;}{  try  {    (dec = decl_variavel(rec)  | LOOKAHEAD(2)    dec = atribuicao(rec)  | dec = decl_chamada_metodo(rec)  | dec = comando_imprimir(rec)  | dec = comando_ler(rec)  | dec = comando_retornar(rec)  | dec = controle_se(rec)  | dec = controle_enquanto(rec))    {      return dec;    }  }  catch (ParseException e)  {    consumirAte(rec, e, "declaracao");    return dec;  }}NoVariavel ident_variavel(Recuperacao rec) throws ParseEOFException :{  Token nome = null;  int tamanho = 0;}{  try  {    nome = < IDENT > [ tamanho = decl_array() ]    {      return new NoVariavel(nome, tamanho);    }  }  catch (ParseException e)  {    consumirAte(rec, e, "ident_variavel");    return new NoVariavel(nome, tamanho);  }}NoVariavelDecl decl_variavel(Recuperacao rec) throws ParseEOFException :{  Recuperacao r = new Recuperacao(VIRGULA);  Token tipo = null;  NoVariavel variavel = null;  NoLista variaveis = null;  NoVariavelDecl resultado = null;}{  try  {    < VARIAVEL > tipo = tipo_primitivo(r) variavel = ident_variavel(r)    {      variaveis = new NoLista(variavel);    }    (< VIRGULA > variavel = ident_variavel(rec)    {      variaveis.adiciona(variavel);    }    ) *    {      return new NoVariavelDecl(tipo, variaveis);    }  }  catch (ParseException e)  {    consumirAte(rec, e, "decl_variavel");    return new NoVariavelDecl(tipo, variaveis);  }}NoAtribuicao atribuicao(Recuperacao rec) throws ParseEOFException :{  Recuperacao r = new Recuperacao(ATRIBUICAO);  NoExpressao esquerda = null;  NoExpressao direita = null;  Token igual = null;}{  try  {    esquerda = valor_esquerdo(r) igual = < ATRIBUICAO > (direita = expressao(rec)  | direita = alocacao(rec))    {      return new NoAtribuicao(igual, esquerda, direita);    }  }  catch (ParseException e)  {    consumirAte(rec, e, "atribuicao");    return new NoAtribuicao(igual, esquerda, direita);  }}NoExpressao valor_esquerdo(Recuperacao rec) throws ParseEOFException :{  Recuperacao r = new Recuperacao(COLCHDIR);  Token nome = null;  NoExpressao expr = null;  NoLista lista = null;  NoVariavel variavel = null;}{  try  {    nome = < IDENT > (< COLCHESQ > expr = expressao(r) < COLCHDIR >    {      if (lista == null)      {        lista = new NoLista(expr);      }      else      {        lista.adiciona(expr);      }    }    ) *    {      if (lista != null)      {        return new NoArray(nome, lista);      }      else      {        return new NoVariavel(nome);      }    }  }  catch (ParseException e)  {    consumirAte(rec, e, "valor_esquerdo");    return new NoVariavel(nome);  }}NoAlocacao alocacao(Recuperacao rec) throws ParseEOFException :{  Recuperacao recTipo = new Recuperacao(COLCHESQ);  Recuperacao recExpr = new Recuperacao(COLCHDIR);  Token novo = null;  Token tipo = null;  NoExpressao tamanho = null;  NoLista array = null;}{  try  {    novo = < NOVO > tipo = tipo_primitivo(recTipo) (< COLCHESQ > tamanho = expressao(recExpr) < COLCHDIR >    {      if (array == null)      {        array = new NoLista(tamanho);      }      else      {        array.adiciona(tamanho);      }    }    ) +    {      return new NoAlocacao(novo, tipo, array);    }  }  catch (ParseException e)  {    consumirAte(rec, e, "alocacao");    return new NoAlocacao(novo, tipo, array);  }}NoExpressao expressao(Recuperacao rec) throws ParseEOFException :{  NoExpressao resultado = null;  NoExpressao esquerda = null;  NoExpressao direita = null;  Token operador = null;}{  try  {    (LOOKAHEAD(2)    esquerda = expressao_numerica()  | LOOKAHEAD(2)    esquerda = chamada_metodo(rec))    {      resultado = esquerda;    }    [      operador = operador_binario() (LOOKAHEAD(2)      direita = expressao_numerica()    | LOOKAHEAD(2)      direita = chamada_metodo(rec))      {        resultado = new NoRelacional(operador, esquerda, direita);      }    ]    {      return resultado;    }  }  catch (ParseException e)  {    consumirAte(rec, e, "expressao");    return resultado;  }}Token operador_binario() :{  Token op = null;}{  (    op = < MAIOR >  | op = < MENOR >  | op = < IGUAL >  | op = < MAIORIGUAL >  | op = < MENORIGUAL >  | op = < DIFERENTE >  )  {    return op;  }}NoChamadaDecl decl_chamada_metodo(Recuperacao rec) throws ParseEOFException :{  NoChamada chamada = null;}{  chamada = chamada_metodo(rec)  {    return new NoChamadaDecl(chamada);  }}NoChamada chamada_metodo(Recuperacao rec) throws ParseEOFException :{  Recuperacao r = new Recuperacao(PARENDIR);  Token metodo = null;  NoLista argumentos = null;}{  try  {    metodo = < IDENT > < PARENESQ > [ argumentos = argumentos(r) ] < PARENDIR >    {      return new NoChamada(metodo, argumentos);    }  }  catch (ParseException e)  {    consumirAte(rec, e, "chamada_metodo");    return new NoChamada(metodo, argumentos);  }}NoLista argumentos(Recuperacao rec) throws ParseEOFException :{  NoLista resultado = null;  NoExpressao expr = null;}{  try  {    expr = expressao(rec)    {      resultado = new NoLista(expr);    }    (< VIRGULA > expr = expressao(rec)    {      resultado.adiciona(expr);    }    ) *    {      return resultado;    }  }  catch (ParseException e)  {    consumirAte(rec, e, "argumentos");    return resultado;  }}NoExpressao expressao_numerica() throws ParseEOFException :{  Token op = null;  NoExpressao esquerda = null;  NoExpressao direita = null;}{  esquerda = termo()  (    (      op = < MAIS >    | op = < MENOS >    )    direita = termo()    {      esquerda = new NoAdicao(op, esquerda, direita);    }  )*  {    return esquerda;  }}NoExpressao termo() throws ParseEOFException :{  NoExpressao esquerda = null;  NoExpressao direita = null;  Token op = null;}{  esquerda = expressao_unaria()  (    (      op = < MULTIPLICACAO >    | op = < DIVISAO >    | op = < RESTO >    )    direita = expressao_unaria()    {      esquerda = new NoMultiplicacao(op, esquerda, direita);    }  )*  {    return esquerda;  }}NoExpressao expressao_unaria() throws ParseEOFException :{  Token op = null;  NoExpressao fator = null;}{  [    op = < MAIS >  | op = < MENOS >  ]  fator = fator()  {    if (op == null)    {      return fator;    }    else    {      return new NoUnario(op, fator);    }  }}NoExpressao fator() throws ParseEOFException :{  Recuperacao r = new Recuperacao(PARENDIR);  NoExpressao fator = null;  Token constante = null;}{  (    constante = < CONST_INTEIRO >    {      fator = new NoInteiro(constante);    }  | constante = < CONST_DECIMAL >    {      fator = new NoDecimal(constante);    }  | constante = < CONST_TEXTO >    {      fator = new NoTexto(constante);    }  | constante = < CONST_NULO >    {      fator = new NoNulo(constante);    }  | fator = valor_esquerdo(null)  | < PARENESQ > fator = expressao(r) < PARENDIR >  )  {    return fator;  }}NoImprimir comando_imprimir(Recuperacao rec) throws ParseEOFException :{  Recuperacao r = new Recuperacao(PARENDIR);  Token escrever = null;  NoExpressao valor = null;}{  try  {    escrever = < ESCREVER > < PARENESQ > valor = expressao(r) < PARENDIR >    {      return new NoImprimir(escrever, valor);    }  }  catch (ParseException e)  {    consumirAte(rec, e, "comando_imprimir");    return new NoImprimir(escrever, valor);  }}NoLer comando_ler(Recuperacao rec) throws ParseEOFException :{  Recuperacao r = new Recuperacao(PARENDIR);  Token ler = null;  NoExpressao variavel = null;}{  try  {    ler = < LER > < PARENESQ > variavel = expressao(r) < PARENDIR >    {      return new NoLer(ler, variavel);    }  }  catch (ParseException e)  {    consumirAte(rec, e, "comando_ler");    return new NoLer(ler, variavel);  }}NoRetornar comando_retornar(Recuperacao rec) throws ParseEOFException :{  Token retorna = null;  NoExpressao valor = null;}{  try  {    retorna = < RETORNA >    [      LOOKAHEAD(2)      valor = expressao(rec)    ]    {      return new NoRetornar(retorna, valor);    }  }  catch (ParseException e)  {    consumirAte(rec, e, "comando_retornar");    return new NoRetornar(retorna, valor);  }}NoSe controle_se(Recuperacao rec) throws ParseEOFException :{  Recuperacao r = new Recuperacao(PARENDIR);  Token se = null;  NoExpressao condicao = null;  NoBloco verdadeiro = null;  NoBloco falso = null;}{  try  {    se = < SE > < PARENESQ > condicao = expressao(r) < PARENDIR > verdadeiro = bloco(rec)    [      LOOKAHEAD(2)      < SENAO > falso = bloco(rec)    ]    {      return new NoSe(se, condicao, verdadeiro, falso);    }  }  catch (ParseException e)  {    consumirAte(rec, e, "comando_se");    return new NoSe(se, condicao, verdadeiro, falso);  }}NoEnquanto controle_enquanto(Recuperacao rec) throws ParseEOFException :{  Recuperacao r = new Recuperacao(PARENDIR);  Token enquanto = null;  NoExpressao condicao = null;  NoBloco bloco = null;}{  try  {    enquanto = < ENQUANTO > < PARENESQ > condicao = expressao(r) < PARENDIR > bloco = bloco(rec)    {      return new NoEnquanto(enquanto, condicao, bloco);    }  }  catch (ParseException e)  {    consumirAte(rec, e, "controle_enquanto");    return new NoEnquanto(enquanto, condicao, bloco);  }}